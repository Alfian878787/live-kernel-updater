#!/bin/bash

      ME=${0##*/}
  MY_DIR=$(dirname "$(readlink -f $0)")

#== BEGIN_CONFIG

         LIVE_MP="/live/boot-dev"
        LIVE_DIR="antiX"
        BOOT_DIR="boot"

    LINUXFS_FILE="linuxfs"
    VMLINUZ_FILE="vmlinuz"
  VMLINUZ_2_FILE="vmlinuz1"
     INITRD_FILE="initrd.gz"

        # for kernel and initrd.gz files
       KOLD_EXT=".kold"
       KBAD_EXT=".kbad"
        MD5_EXT=".md5"

        # For linuxfs file (right after a remaster)
         NEW_EXT=".new"

        BZ2_OPTS="-c -9"
         GZ_OPTS="-c -9"
         LZ_OPTS="-c -9"
         XZ_OPTS="-c -z --format=lzma"

       CPIO_OPTS="-o -H newc --owner root:root --quiet"

       SHELL_LIB="cli-shell-utils.bash"
        LIB_PATH="/usr/local/lib/shell-utils"

#== END_CONFIG

        WORK_DIR="/run/$ME"
            FIFO="/run/$ME/fifo"
       LOCK_FILE="/run/lock/$ME"
    THE_LOG_FILE="/var/log/$ME.log"
    THE_ERR_FILE="/var/log/$ME.errors"
        LOG_FILE="/dev/null"
        ERR_FILE="/dev/null"

        ALL_CMDS="rollback all unpack copy repack install"
       ALL_FORCE="all,rollback,flock,clear,missing-mod,compress"
       ALL_PAUSE="all,fifo,mount,unpack,copy,repack,clean"

            PATH="$MY_DIR:/usr/local/share/$ME/bin:$PATH"

usage() {
    local ret=${1:-0}

cat<<Usage
Usage: $ME [options] [command]
Update the kernel on a running antiX or MX live-usb.  The new
kernel must already be installed.  If the name (uname -r) of the new
kernel is not give then you will be prompted for it from a menu.

Commands:
   rollback    Undo changes
   all         All commands below
   unpack      Unpack the old initrd
   copy        Copy kernel modules into initrd
   repack      Repack the new initrd
   install     Copy new initrd and vmlinuz to the live boot directory

Options:
  -a --auto             Non-interactive.  Always assume the safe answer
  -D --debug            Pause before cleaning up
  -d --device=<device>  A live-usb to update the kernel on
                        (instead of on the running live system)
  -f --force=XXXX       Force the options specfied:
                                flock:  ignore missing flock program
                                clear:  remove previous initrd directory
                             compress:  use gzip instead of unknown compression
                             rollback:  always rollback if we've previously updated
  -h --help             Show this usage
  -i --initrd=<name>    Name of initrd file ($INITRD_FILE)
  -k --kernel=<kernel>  The version (uname -r) of the new kernel
  -K --keep-old         Keep the old module directory in the initrd
  -p --pretend          Don't run most commands, just show them
  -P --pause=<list>     Pause after certain stages of processing:
                            mount
                            unpack
                            copy
                            repack
                            install

  -q --quiet            Print less
  -v --verbose          Print more, show commands when run

Notes:
  - short options stack. Example: -pq instead of -p -q
  - options can be intermingled with commands and parameters
Usage
    exit $ret
}

eval_argument() {
    local arg=$1 val=$2
    case $arg in
              -auto|a)  AUTO_MODE=true                  ;;
            -device|d)  DEVICE=$val                     ;;
            -device=*)  DEVICE=$val                     ;;
             -debug|D)  DEBUG=true                      ;;
             -force|f)  FORCE="$FORCE${FORCE:+,}$val"   ;;
             -force=*)  FORCE="$FORCE${FORCE:+,}$val"   ;;
#               -fifo)  FIFO_MODE=true                  ;;
            -initrd|i)  CMD_INITRD=$val                 ;;
            -initrd=*)  CMD_INITRD=$val                 ;;
            -kernel|k)  NEW_KERNEL=$val                 ;;
            -kernel=*)  NEW_KERNEL=$val                 ;;
          -keep-old|K)  KEEP_OLD=true                   ;;
           -pretend|p)  PRETEND=true ; BE_VERBOSE=true  ;;
             -pause|P)  PAUSE="$PAUSE${PAUSE:+,}$val"   ;;
             -pause=*)  PAUSE="$PAUSE${PAUSE:+,}$val"   ;;
             -quiet|q)  QUIET=true                      ;;
           -verbose|v)  BE_VERBOSE=true                 ;;
               *)  fatal "Unknown parameter %s" "-$arg" ;;
    esac
}

takes_param() {
    case $1 in
          -device|d) return 0 ;;
          -initrd|i) return 0 ;;
           -force|f) return 0 ;;
          -kernel|k) return 0 ;;
           -pause|P) return 0 ;;
    esac
    return 1
}

assign_parameter() {
    local cnt=$1 param=$2
   case $cnt in
        *) CMDS="$CMDS${CMD:+ }$param" ;;
    esac
}

main() {
    local SHIFT SHORT_STACK="adDfhikKpPqv"
    local BE_VERBOSE
    local orig_args="$*"

    [ $# -eq 0 ] && usage

    read_all_cmdline_mingled "$@"

    #[ $opt_cnt -ne 1 ] && fatal 011 "Expected one command line argument"

    EXIT_NUM=100
    [ $UID -eq 0 ] || fatal 101 "This script must be run as root"

    need_prog vmlinuz-version copy-initrd-modules

    trap clean_up EXIT

    do_flock $LOCK_FILE $ME
    check_cmds  CMDS  "$ALL_CMDS"
    check_force FORCE "$ALL_FORCE"
    check_pause PAUSE "$ALL_PAUSE"

    #[ "$FIFO_MODE" -a "$AUTO_MODE" ] && fatal "Cannot select both %s and %s" "--fifo" "--auto"

    [ "$PRETEND" ] && Msg "PRETEND MODE ENABLED"

     USB_DIR=$WORK_DIR/usb
    SQFS_DIR=$WORK_DIR/linux

    local root_dir=$SQFS_DIR

    # FIXME When to clear?  When to clean?
    [ "$CLEAR_WORK" ] && rm -rf "$WORK_DIR"
    mkdir -p $WORK_DIR || fatal 120 "Could not make a work directory under /tmp"

    # Are we going to update a running live system or an plugged in live-usb?
    local usb_dev dev_type live_mp

    #----- RUNNING LIVE -------------------------------------------------------
    if its_alive && [ ${#DEVICE} -eq 0 ]; then
        UPDATE_LIVE=true
        live_mp=$LIVE_MP

    #----- LIVE-USB -----------------------------------------------------------
    else
        if [ ${#DEVICE} -eq 0 ]; then
            fatal "Must specify a device if not running live (for now)"
        fi

        usb_dev=$(expand_device $DEVICE)
        fatal_z "$usb_dev" $"Could not find device %s" "$DEVICE"
        dev_type=$(lsblk -no type --nodeps $usb_dev)
        [ "$dev_type" = "part" ] || fatal $"Device %s is not a disk partition" $usb_dev

        my_mount $usb_dev $USB_DIR
        live_mp=$USB_DIR
    fi

    is_mountpoint "$live_mp" || fatal "Expected '%s' to be a mountpoint" "$live_mp"

    local full_live_dir=$live_mp/${LIVE_DIR#/}
    check_writable "$full_live_dir" "live boot"

    # Find the linuxfs file (where we get new kernels and modules from)
    local ext file linuxfs_file
    for ext in "$NEW_EXT" ""; do
        file=$full_live_dir/$LINUXFS_FILE$ext
        test -r $file || continue
        linuxfs_file=$file
        break
    done

    fatal_z "$linuxfs_file" "Could not find '%s' or '%s' on the live-usb" \
        $(pqh "$LINUXFS_FILE$NEW_EXT") $(pqh "$LINUXFS_FILE")

    local live_remaster
    if [ -z "${linuxfs_file%%*$NEW_EXT}" ]; then
        live_remaster=true
        msg "Found %s file %s" $(pq live-remaster) $(pq $(basename $linuxfs_file))
    else
        msg "Found %s file %s" $(pq linuxfs) $(pq $(basename $linuxfs_file))
    fi

    # Fix me?
    my_mount "$linuxfs_file" "$root_dir" -t squashfs -o loop,ro
    local full_boot_dir="$root_dir/${BOOT_DIR#/}"

    pause mount
    start_log "$orig_args"

    local default_vm=$VMLINUZ_FILE  second_vm=$VMLINUZ_2_FILE

    local live_all=$(vmlinuz-version -nsr -d : "$full_live_dir")
    local boot_all=$(vmlinuz-version -nsr -d : "$full_boot_dir")

    local live_cnt=$(echo  "$live_all" | grep -c .)
    local boot_cnt=$(echo  "$boot_all" | grep -c .)
    local live_files=$(echo "$live_all" | cut -d: -f2)

    fatal_0 $boot_cnt "Found no kernels in the boot directory"
    fatal_0 $live_cnt "Found no kernels in the live boot directory"

    # Find/get current vmlinuz file (usually vmlinuz or vmlinuz1)
    local current_vmlinuz current_version

    #----- RUNNING LIVE -------------------------------------------------------
    #
    if [ "$UPDATE_LIVE" ]; then
        msg "Updating live system"
        current_version=$(uname -r)
        current_vmlinuz=$(vmlinuz-version --current $full_live_dir)

        if [ ${#current_vmlinuz} - eq 0 ]; then
            fatal "Could not find the current vmlinuz file in %s" "$full_live_dir"
        elif [ -z "${current_vmlinuz##*$KOLD_EXT}" ]; then
            fatal "FIXME: force rollback"
        elif [ -z "${current_vmlinuz##*$KBAD_EXT}" ]; then
            fatal "FIXME: what to do with .bad current vmlinuz file??"
        fi

    #----- LIVE-USB -----------------------------------------------------------
    #
    else
        msg "Updating live-usb on device %s" "$(pq "$usb_dev")"
        if echo "$live_files" | grep -q "^$default_vm$" && echo "$live_files" | grep -q "^second_vm$"; then
            fatal "fixme: select %s versus %s" $default_vm $second_vm
        fi

        current_version=$(echo "$live_all" | sed -n "s/^\([^:]\+\):$default_vm:.*/\1/p")
        fatal_z "$current_version" "Could not find a default live kernel in: %s" "$(echo $live_files)"
        current_vmlinuz=$default_vm
    fi

    #msg "current kernel version: %s" "$(pq "$current_version")"

    local new_all=$(echo "$boot_all" | grep -v "^$current_version:")
    local new_cnt=$(echo "$new_all" | wc -l)
    local new_versions=$(echo "$new_all" | sed -rn "s/^([^:]+):.*/\1/p")


    #----- CMDLINE NEW KERNEL -------------------------------------------------
    #
    if [ ${#NEW_KERNEL} -gt 0 ]; then
        [ "x$NEW_KERNEL" = "x$current_version" ] \
            && fatal "The new kernel %s is the same as the current one" "$NEW_KERNEL"

        if ! echo "$new_all" | grep -q "^$NEW_KERNEL:"; then
            msg "Found %s new kernel(s): %s" "$new_cnt" "$hi_co$(echo; echo "$new_versions" | sed 's/^/  /')$nc_co"

            fatal "Could not find new kernel %s in boot directory" "$NEW_KERNEL"
        fi
        exit


    #----- SELECT NEW KERNEL --------------------------------------------------
    #
    else
        case $new_cnt in
            0)  fatal "Did not find any new kernels in the boot directory"  ;;
            1)  msg "assumig %s is the new kernel" "$(pq $new_all)"
                new_kernel=$new_all                                         ;;
            *) fatal "Fixme: select new kernel from: %s" "$(echo $new_all)" ;;
        esac
    fi

    local new_version=$(echo "$new_kernel" | cut -d: -f1)
    local new_file=$(echo "$new_kernel" | cut -d: -f2)
    local rel_mod_dir="/lib/modules/$new_version"
    local new_mod_dir="$root_dir$rel_mod_dir"
    test -e "$new_mod_dir" || fatal "The module directory '%s' does not exist"     "$rel_mod_dir"
    test -d "$new_mod_dir" || fatal "The module directory '%s' is not a directory" "$rel_mod_dir"

    #-- local base_vmlinuz=$(basename "$current_vmlinuz")

    #-- force rollback || [ -n "${base_vmlinuz##*.old}" ] || yes_NO_fatal "rollback" \
    #--         "$(printf "Do you want to overwrite the backup '%s' file" "$base_vmlinuz")" \
    #--         "Use --force=overwrite to always overwrite backups" \
    #--         "The current vmlinuz file '%s' looks like a backup file" "$base_vmlinuz"

    #-- local new_kernel_file=$(vmlinuz-version -Nnr -d=:: "$BOOT_DIR" | sed -n "s/^$NEW_KERNEL:://p")

    local new_kernel_name=$(basename "$new_kernel_file")

    local info_fmt="%25s:$white %s"
    msg
    msg "$info_fmt" "Current kernel version" "$current_version"
    msg "$info_fmt" "New kernel version"     "$new_version"
    msg "$info_fmt" "Current vmlinuz file"   "$current_vmlinuz"
    #msg "$info_fmt" "New module directory"   "$rel_mod_dir"
    #msg "$info_fmt" "New kernel file"        "$new_file"
    msg

    #msg "got here"; exit

    full_initrd="$full_live_dir/$INITRD_FILE"
    test -e "$full_initrd" || fatal "Could not find initrd file: %s" "$full_initrd"

    local initrd_dir=$WORK_DIR/initrd
    local tmp_initrd_file="$WORK_DIR/$(basename $full_initrd).tmp"
    local compression_file="$WORK_DIR/compression"
    local cpio_files="$WORK_DIR/cpio.{in,out}"

    if [ ${#CMDS} -le 0 ]; then
        echo -e "No command(s) given.  Try 'all'."
        exit 0
    fi

    #--------------------------------------------------------------------------
    #----- REAL WORK STARTS HERE ----------------------------------------------
    #--------------------------------------------------------------------------
    if need unpack; then

        if force clear; then
            cmd rm -rf "$initrd_dir/../initrd"
            cmd rm -f "$tmp_initrd_file" $compression_file $cpio_files
        else
            test -d "$initrd_dir" && yes_NO_fatal "clear" \
                "Do you want to delete it now"            \
                "Use --force=clear to always delete it"   \
                "Will not over-write an existing initrd directory."
        fi

        unpack_initrd "$full_initrd" "$initrd_dir"  "$compression_file"
    fi

    pause unpack

    old_initrd_mods="$initrd_dir/lib/modules/$current_version"

    force missing-mod || test -d "$old_initrd_mods" || yes_NO_fatal "missing-mod" \
        "Something is wrong but this may still work.  Do you want to continue anyway" \
        "Use --force=missing-mod to ignore this in the future" \
        "There is no module directory for the current kernel in the initrd"

    #[ -z "$KEEP_OLD" ] && test -d "$old_initrd_mods" && cmd rm -rf "$old_initrd_mods"

    need copy && cmd copy-initrd-modules --quiet --count --from="$root_dir" --to="$initrd_dir" --kernel="$new_version"
    pause copy

    need repack && repack_initrd "$initrd_dir" "$tmp_initrd_file"  "$compression_file"
    pause repack

    if need install; then
        do_install "$tmp_initrd_file" "$full_initrd"
        do_install "$full_boot_dir/$new_file" "$full_live_dir/$current_vmlinuz"
    fi
    pause install

    my_exit 0
}

unpack_initrd() {
    local file=$1  dir=$2  compression_file=$3
    local compression=$(file -b "$file" | cut -d" " -f1)

    local compress args
    case $compression in
         gzip) compress="gzip"   ; args="-cd"  ;;
        bzip2) compress="bzip2"  ; args="-cd"  ;;
         lzip) compress="lzip"   ; args="-cd"  ;;
           XZ) compress="xz"     ; args="-cd"  ;;
            *) fatal "Don't know how to decompress a '%s' file" "$compression" ;;
    esac
    echo "$compress" > $compression_file

    need_prog $compress
    my_mkdir "$dir"

    local cpio_file="$dir.in"
    $compress $args "$file" > "$cpio_file" || fatal "The decompression program '%s' failed" "$decomp"

    local unpack archive_type=$(file -b "$cpio_file")
    case $archive_type in
        *" cpio archive"*) unpack="cpio" ; args="-idum --quiet" ;;
         *" tar archive"*) unpack="tar"  ; args="-x"            ;;
                       *) fatal "unknown initrd archive type '%s'" "$archive_type"
    esac
    (cd "$dir" && $unpack $args) < "$cpio_file" || fatal "The %s extraction failed" "$unpack"
}

repack_initrd() {
    local dir=$1  file=$2  compression_file=$3
    local compress
    read compress 2>/dev/null < $compression_file
    : ${compress:=gzip}

    local args
    case $compress in
         bzip2) args="$BZ2_OPTS" ;;
          gzip) args="$GZ_OPTS"  ;;
          lzip) args="$LZ_OPTS"  ;;
            xz) args="$XZ_OPTS"  ;;
             *) yes_NO_fatal "compress" \
               "Do you want to continue on using gzip compression?" \
               "Use %s to skip this question in the future" \
               "Unknown compression format: %s" "$compression"
                compress="gzip" ; args="$GZIP_OPTS"  ;;
    esac

    need_prog $compress

    local cpio_file="$dir.out"
    (cd "$dir" && find . | cpio $CPIO_OPTS) > $cpio_file \
        || fatal "Could not create a cpio archive"

    msg "Compressing ..."
    $compress $args < "$cpio_file" > "$file" || fatal "Compression (%s) failed" $compress
}

do_install() {
    local from=$1  dest=$2
    test -f "$from" || fatal "Installation file %s does not exist" "$from"

    msg "install %s" "$(pq $(basename $dest))"
    #msg "install %s --> %s" "$from" "$dest"

    if test -e "$dest"; then
        if [ -n "${dest%%*$KOLD_EXT}" ]; then
            local backup="$dest$KOLD_EXT"
            msg "backing up %s to %s" "$(pq $(basename "$dest"))" "$(pq $(basename "$backup"))"
            cmd mv "$dest" "$backup"
        else
            warn "Overwriting backup"
        fi
    else
        warn "Target file %s does not exist" "$dest"
    fi

    cmd cp "$from" "$dest"

   local md5=$dest$MD5_EXT
   if test -e $md5; then
       cmd mv $md5 $md5$KOLD_EXT
       (cd $(dirname $dest) && md5sum $(basename $dest) > $dest$MD5_EXT)
    fi
}

do_rollback() {
    local dir=$1  vmlinuz=$2  initrd=$3

    local old_vmlinuz bad_vmlinuz the_vmlinuz f
    for f in $vmlinuz$KOLD_EXT ${vmlinuz}1$KOLD_EXT; do
        test -e $dir/$f || continue
        msg "Found old vmlinuz file %s" $f
        old_vmlinuz="$dir/$f"
        bad_vmlinuz=${old_vmlinuz%%$KOLD_EXT}$PREV_EXT
        the_vmlinuz="$dir/$f"
        break
    done
    [ "$old_vmlinuz" ] || fatal "Could not find old %s file to roll back" $vmlinuz

    local new_initrd="$dir/$initrd$KOLD_EXT"
    local bad_initrd="$dir/$initrd$PREV_EXT"
    local the_initrd="$dir/$initrd"

    [ "$old_vmlinuz" ] || fatal "Could not find old %s file to roll back" $initrd

    cmd mv "$the_initrd" "$bad_initrd"
    cmd mv "$old_initrd" "$the_initrd"

    cmd mv "$the_vmlinuz" "$bad_vmlinuz"
    cmd mv "$old_vmlinuz" "$the_vmlinuz"
}

my_exit() {
    local ret=${1:-0}

    if [ "$DEBUG" ]; then
        echo -n "${green}Press <Enter>$nc_co "
        read x
    fi

    Msg "=> cleaning up"
    exit $ret
}

start_log() {
    local args=$1 cmds=${2# }

    LOG_FILE=$THE_LOG_FILE
    ERR_FILE=$THE_ERR_FILE

    rm -f $ERR_FILE

    cat <<Start_Log >> $LOG_FILE
---------------------------------------------------------------------
$ME
    started: $(date)
comand line: $args
  found lib: $FOUND_LIB

Start_Log
}

clean_up() {
    sync; sync
    for mp in $USB_DIR $SQFS_DIR; do
        is_mountpoint $mp && umount -r -l $mp
        if ! is_mountpoint $mp; then
            rm -rf $mp
        else
            warn "%s remains mounted" "$mp"
            continue
        fi
    done
    if test -d $WORK_DIR; then
        test -d $WORK_DIR/initrd && rm -rf $WORK_DIR/initrd
        for file in $(ls $WORK_DIR); do
            full=$WORK_DIR/$file
            [ -f $full -o -p $full ] && rm $full
        done

        rmdir $WORK_DIR
    fi

    rm -f $LOCK_FILE
}

load_lib() {
    local file=$1 path=$2
    shift

    unset FOUND_LIB
    local dir lib found orig_ifs=$IFS
    IFS=:
    for dir in $path; do
        lib=$dir/$file
        test -r $lib || continue
        if ! . $lib; then
            printf "Error when loading library %s\n" "$lib" >&2
            printf "This is a fatal error\n" >&2
            exit 15
        fi
        FOUND_LIB=$lib
        IFS=$orig_ifs
        return 0
    done

    printf "Could not find library '%s' on path '%s'\n" "$file" "$path" >&2
    printf "This is a fatal error\n" >&2
    exit 17
}

#===== Start Here =============================================================
LIB_PATH="$LIB_PATH:$MY_DIR/../cli-shell-utils:$MY_DIR"
load_lib "$SHELL_LIB" "$LIB_PATH"

set_colors

main "$@"

